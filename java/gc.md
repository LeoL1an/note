## 回收算法：

1. 标记-清除算法
2. 标记-压缩
3. 

## 年轻代：

1. Serial：单线程、暂停所有进程、复制算法、单核CPU小程序
2. ParNew：Serial的并发版、多线程、多核CPU小程序、Serial的并发版
3. Parallel Scavenge：多线程
    - -XX:MaxGCPauseMillis：最大垃圾回收停顿时间
    - -XX:GCTimeRatio：垃圾回收时间与总时间占比
    - -XX:UseAdaptiveSizePolicy：动态调整各个区域比例的大小的开关

## 老年代：

1. Serial Old：Serial相同，标记整理算法
2. Parallel Old：Parallel Scavenge相同，标记整理算法
3. CMD：优点：标记清除算法、并发、低停顿（耗时操作为并发执行）；缺点：CPU资源要求高（CPU负载高时不太好）、并发产生浮动垃圾无法处理（不能等分区满在执行，需要预留空间供给并发清除时使用）、标记清除产生内存碎片
    - 初始标记（initial mark）：暂停所有线程、GC Roots可达标记、速度快
    - 并发标记（concurrent mark）：追踪标记、并发不影响程序
    - 重新标记（remark）：暂停所有线程、追加标记上两步过程中产生的垃圾、速度较快
    - 并发清除（concurrent sweep）：清除垃圾、并发不影响程序

## 新老年代通用：

G1：

优点：

- 并发与并行
- 分代收集
- 空间整合：整体看标记-整理算法，局部看时复制算法
- 可预测停顿



- 分成多个大小相等的区域（region），保留新生代老年代概念，取消物理隔离，实际各自为一部分区域的集合
- 对象引用避免全堆扫描，

|      收集器       | 串行、并行or并发 | 新生代/老年代 |        算法        |   目标   | 适用场景                                  |
| :---------------: | :--------------: | :-----------: | :----------------: | :------: | ----------------------------------------- |
|      Serial       |       串行       |    新生代     |      复制算法      | 响应速度 | 单CPU环境下的Client模式                   |
|    Serial Old     |       串行       |    老年代     |     标记-整理      | 响应速度 | 单CPU环境下的Client模式、CMS的后备预案    |
|      ParNew       |       并行       |    新生代     |      复制算法      | 响应速度 | 多CPU环境时在Server模式下与CMS配合        |
| Parallel Scavenge |       并行       |    新生代     |      复制算法      |  吞吐量  | 在后台运算而不需要太多交互的任务          |
|   Parallel Old    |       并行       |    老年代     |     标记-整理      |  吞吐量  | 在后台运算而不需要太多交互的任务          |
|        CMS        |       并发       |    老年代     |     标记-清除      | 响应速度 | 集中在互联网站或B/S系统服务端上的Java应用 |
|        G1         |       并发       |     both      | 标记-整理+复制算法 | 响应速度 | 面向服务端应用，将来替换CMS               |



ZGC：